---
import type { ScheduleEvent as TScheduleEvent } from '#/data/schedule';
import EventItem from './EventItem.astro';

interface Props {
  events: TScheduleEvent[];
  locale?: Intl.UnicodeBCP47LocaleIdentifier;
  dateHeaderFormat?: Intl.DateTimeFormatOptions['weekday'];
  dateRange?: { start: Date; end: Date };
}

const {
  events = [],
  locale = 'en-EN',
  dateHeaderFormat = 'short',
  dateRange = calculateDateRangeFromEvents(events)
} = Astro.props;

// Calculate default date range from events if not provided
function calculateDateRangeFromEvents(events: TScheduleEvent[]): { start: Date; end: Date } {
  if (events.length === 0) {
    const today = new Date();
    return { start: today, end: today };
  }

  let minDate = events[0]!.start;
  let maxDate = events[0]!.end ?? events[0]!.start;

  events.forEach((event) => {
    const endDate = event.end ?? event.start;

    if (event.start < minDate) {
      minDate = event.start;
    }
    if (endDate > maxDate) {
      maxDate = endDate;
    }
  });

  return { start: minDate, end: maxDate };
};

// @ts-expect-error - getWeekInfo is not widely supported yet, so there are no types for it
const firstDayOfWeek = new Intl.Locale(locale).getWeekInfo?.()?.firstDay ?? 1;
const dayNames = (() => {
  const formatter = new Intl.DateTimeFormat(locale, { weekday: dateHeaderFormat });

  // Create date adjusted to the first day of the week of the locale, using as reference a known monday date
  const baseDate = new Date(2025, 0, 6); // Lunes, 6 de enero de 2025

  // Adjust to the locale's first day of week
  const adjustment = (firstDayOfWeek === 7 ? 0 : firstDayOfWeek) - 1;
  baseDate.setDate(baseDate.getDate() - baseDate.getDay() + 1 + adjustment);

  /**
   * Starting from the locale's first day of week, generate the names of the week days
   * in the specified locale.
   */
  const weekDays = Array.from({ length: 7 }, (_, i) => {
    const date = new Date(baseDate);
    date.setDate(baseDate.getDate() + i);
    return formatter.format(date);
  });

  return weekDays;
})();

/**
 * Creates a localized title showing the date range in the format appropriate for the locale.
 * Examples: "August 31 - September 5" (en), "31 agosto - 5 septiembre" (es)
 */
function formatWeekTitle(startDate: Date, endDate: Date): string {
  const startFormatter = new Intl.DateTimeFormat(locale, {
    month: 'long',
    day: 'numeric'
  });

  const endFormatter = new Intl.DateTimeFormat(locale, {
    month: 'long',
    day: 'numeric'
  });

  // Check if it's the same month and year
  const startMonth = startDate.getMonth();
  const startYear = startDate.getFullYear();
  const endMonth = endDate.getMonth();
  const endYear = endDate.getFullYear();

  if (startMonth === endMonth && startYear === endYear) {
    // Same month: "August 31 - 5" or "31 - 5 agosto" depending on locale
    const dayOnlyFormatter = new Intl.DateTimeFormat(locale, {
      day: 'numeric'
    });

    const startFormatted = startFormatter.format(startDate);
    const endDay = dayOnlyFormatter.format(endDate);

    return `${startFormatted} - ${endDay}`;
  }

  // Different months: "August 31 - September 5" or "31 agosto - 5 septiembre"
  const startFormatted = startFormatter.format(startDate);
  const endFormatted = endFormatter.format(endDate);

  return `${startFormatted} - ${endFormatted}`;
}

/**
 * For formatting in the time column, we use a 24-hour format without AM/PM.
 */
function formatHour(hour: number): string {
  const date = new Date();
  date.setHours(hour, 0, 0, 0);

  const formatter = new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    minute: '2-digit',
    hour12: false
  });

  return formatter.format(date);
}

function getDaysInRange(startDate: Date, endDate: Date): Date[] {
  const days = [];
  const currentDate = new Date(startDate);

  while (currentDate <= endDate) {
    days.push(new Date(currentDate));
    currentDate.setDate(currentDate.getDate() + 1);
  }

  return days;
}

const weekDays = getDaysInRange(dateRange.start, dateRange.end);

// Enhanced event positioning for overlapping events
interface PositionedEvent extends TScheduleEvent {
  leftOffset: number;
  width: number;
  column: number;
  totalColumns: number;
}

/**
 * Detects overlapping events and calculates their positioning.
 * Only events that actually overlap will share width - independent events get full width.
 */
function calculateEventPositions(events: TScheduleEvent[]): PositionedEvent[] {
  if (events.length === 0) return [];

  // Helper function to check if two events overlap
  function eventsOverlap(event1: TScheduleEvent, event2: TScheduleEvent): boolean {
    const event1End = event1.end ?? new Date(event1.start.getTime() + 60 * 60 * 1000);
    const event2End = event2.end ?? new Date(event2.start.getTime() + 60 * 60 * 1000);

    return event1.start < event2End && event2.start < event1End;
  }

  // Group events that overlap with each other
  const overlapGroups: TScheduleEvent[][] = [];
  const processedEvents = new Set<TScheduleEvent>();

  for (const event of events) {
    if (processedEvents.has(event)) continue;

    // Find all events that overlap with this one (including transitively)
    const currentGroup: TScheduleEvent[] = [event];
    processedEvents.add(event);

    // Keep expanding the group until no more overlapping events are found
    let foundNewOverlap = true;
    while (foundNewOverlap) {
      foundNewOverlap = false;

      for (const candidateEvent of events) {
        if (processedEvents.has(candidateEvent)) continue;

        // Check if candidate overlaps with any event in the current group
        const overlapsWithGroup = currentGroup.some(groupEvent =>
          eventsOverlap(candidateEvent, groupEvent)
        );

        if (overlapsWithGroup) {
          currentGroup.push(candidateEvent);
          processedEvents.add(candidateEvent);
          foundNewOverlap = true;
        }
      }
    }

    overlapGroups.push(currentGroup);
  }

  // Calculate positions for each group
  const positionedEvents: PositionedEvent[] = [];

  for (const group of overlapGroups) {
    if (group.length === 1) {
      // Single event with no overlaps - takes full width
      positionedEvents.push({
        ...group[0]!,
        leftOffset: 0,
        width: 100,
        column: 0,
        totalColumns: 1
      });
    } else {
      // Multiple overlapping events - arrange them using a column algorithm
      const sortedGroup = [...group].sort((a, b) => {
        const startDiff = a.start.getTime() - b.start.getTime();
        if (startDiff !== 0) return startDiff;

        const aEnd = (a.end ?? new Date(a.start.getTime() + 60 * 60 * 1000)).getTime();
        const bEnd = (b.end ?? new Date(b.start.getTime() + 60 * 60 * 1000)).getTime();
        return aEnd - bEnd;
      });

      const columns: { events: TScheduleEvent[]; endTime: number }[] = [];
      const eventToColumn = new Map<TScheduleEvent, number>();

      for (const event of sortedGroup) {
        const eventEnd = event.end ?? new Date(event.start.getTime() + 60 * 60 * 1000);
        const eventStartTime = event.start.getTime();
        const eventEndTime = eventEnd.getTime();

        // Find the first available column
        let assignedColumn = -1;

        for (let i = 0; i < columns.length; i++) {
          if (columns[i]!.endTime <= eventStartTime) {
            assignedColumn = i;
            break;
          }
        }

        if (assignedColumn === -1) {
          assignedColumn = columns.length;
          columns.push({ events: [], endTime: 0 });
        }

        columns[assignedColumn]!.events.push(event);
        columns[assignedColumn]!.endTime = eventEndTime;
        eventToColumn.set(event, assignedColumn);
      }

      // Calculate width and position for this group
      const totalColumns = columns.length;
      const columnWidth = 100 / totalColumns;

      for (const event of sortedGroup) {
        const column = eventToColumn.get(event)!;
        positionedEvents.push({
          ...event,
          leftOffset: column * columnWidth,
          width: columnWidth - 0.5, // Small gap between events
          column,
          totalColumns
        });
      }
    }
  }

  return positionedEvents;
}

// Group events by day using Object.groupBy
const eventsByDateKey = Object.groupBy(events, event =>
  `${event.start.getFullYear()}-${event.start.getMonth()}-${event.start.getDate()}`
);

const eventsByDay = weekDays.map((day) => {
  const dayKey = `${day.getFullYear()}-${day.getMonth()}-${day.getDate()}` as `${number}-${number}-${number}`;
  const dayEvents = eventsByDateKey[dayKey] ?? [];

  return {
    date: day,
    events: calculateEventPositions(dayEvents)
  };
});

// Hours from 8 AM to 8 PM
const hours = Array.from({ length: 13 }, (_, i) => i + 8);
---
<div class="h-full min-h-125 w-full lg:min-h-150">
  <div class="h-full flex flex-col overflow-hidden rounded-xl bg-white shadow-md">
    <div class="border-b border-gray-200 bg-gray-50 px-6 py-5">
      <h3 class="m-0 text-xl text-gray-800 font-semibold">{formatWeekTitle(weekDays[0]!, weekDays[weekDays.length - 1]!)}</h3>
    </div>

    <div class="grid flex-1 overflow-hidden" style={`grid-template-columns: 80px repeat(${weekDays.length}, 1fr);`}>
      {/* Time column */}
      <div class="border-r border-gray-200 bg-gray-50">
        <div class="h-20 border-b border-gray-200 bg-gray-50 lg:h-16 md:h-12"></div>
        {hours.map(hour => (
          <div class="relative h-16 flex items-start justify-center border-b border-gray-100 pt-2 lg:h-12 md:h-10">
            <span class="text-xs text-gray-500 font-medium lg:text-[10px]">{formatHour(hour)}</span>
          </div>
        ))}
      </div>

      {/* Day columns */}
      {eventsByDay.map(({ date, events }, dayIndex) => (
        <div class="relative border-r border-gray-200 last:border-r-0">
          <div class="h-20 flex flex-col items-center justify-center border-b border-gray-200 bg-gray-50 font-semibold lg:h-16 md:h-12 md:px-1">
            <div class="mb-1 text-sm text-gray-500 lg:text-xs md:text-[10px]">{dayNames[dayIndex]}</div>
            <div class="text-lg text-gray-800 lg:text-base md:text-sm">{date.getDate()}</div>
          </div>

          <div class="relative h-[832px] lg:h-[624px] md:h-[520px]">
            {hours.map(() => (
              <div class="h-16 border-b border-gray-100 lg:h-12 md:h-10"></div>
            ))}
            {events.map(event => (
              <EventItem
                event={event}
                locale={locale}
                leftOffset={event.leftOffset}
                width={event.width}
              />
            ))}
          </div>
        </div>
      ))}
    </div>
  </div>
</div>
